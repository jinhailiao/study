/***************************************************************************/
/* Copyright (C) 2004, Haisoft有限公司                                     */
/* All rights reserved.                                                    */

/* 文件名称: ELS.C                                                         */
/* 摘    要：七彩俄罗斯方块                                                */

/* 当前版本: 1.0                                                           */
/* 作    者: 廖金海                                                        */
/* 完成日期: 2005.1.20.                                                    */
/***************************************************************************/

/*************************** include files *********************************/
#include <graphics.h>
#include <stdio.h>
#include <bios.h>
#include <stdlib.h>
#include <dos.h>

/***************************** macro define ********************************/
#define ENTER 0x1c0d
#define ESC   0x011b
#define UP    0x4800
#define DOWN  0x5000
#define LEFT  0x4b00
#define RIGHT 0x4d00
#define SPACE 0x3920

/*************************** Hanzi Mat **************************************/
char qi[72] =     /* 以下是 '七' 的 24点阵黑体 字模，72 byte */
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x60,0x00,0x00,0x60,0x00,0x00,
 0x60,0x00,0x00,0x60,0x00,0x00,0x60,0x00,
 0x00,0x60,0x3C,0x00,0x63,0xF8,0x00,0x7F,
 0x80,0x07,0xF8,0x00,0x3F,0xE0,0x00,0x30,
 0x60,0x00,0x00,0x60,0x00,0x00,0x60,0x00,
 0x00,0x60,0x00,0x00,0x60,0x00,0x00,0x60,
 0x0C,0x00,0x60,0x1C,0x00,0x7F,0xF8,0x00,
 0x3F,0xF0,0x00,0x00,0x00,0x00,0x00,0x00};

char cai[72] =    /* 以下是 '彩' 的 24点阵黑体 字模，72 byte */
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,
 0x00,0x03,0xFC,0x18,0x3F,0x80,0x18,0x10,
 0x00,0x30,0x01,0x0C,0x60,0x31,0x98,0xC0,
 0x19,0x9B,0x80,0x19,0x11,0x08,0x00,0x00,
 0x1C,0x01,0x80,0x38,0x01,0x84,0x70,0x3F,
 0xFC,0xE0,0x03,0x81,0xC0,0x03,0x83,0x04,
 0x07,0xF0,0x0E,0x0D,0xB8,0x1C,0x19,0x8C,
 0x38,0x39,0x80,0xE0,0x71,0x81,0xC0,0x01,
 0x87,0x80,0x01,0x82,0x00,0x00,0x00,0x00};

char e[72] =      /* 以下是 '俄' 的 24点阵黑体 字模，72 byte */
{0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x00,
 0xC0,0x06,0x04,0x80,0x06,0x7E,0x98,0x0E,
 0x70,0x9C,0x0C,0x10,0x8C,0x0C,0x10,0x80,
 0x1C,0x10,0x80,0x3C,0xFF,0xFC,0x3C,0x10,
 0xC0,0x2C,0x10,0xC0,0x0C,0x10,0xC0,0x0C,
 0x16,0xCC,0x0C,0x3E,0xD8,0x0D,0xF0,0x70,
 0x0C,0x90,0x70,0x0C,0x10,0x60,0x0C,0x10,
 0xE0,0x0C,0x13,0xB6,0x0C,0x33,0x3E,0x0C,
 0x70,0x1C,0x0C,0x40,0x0C,0x00,0x00,0x00};

char luo[72] =    /* 以下是 '罗' 的 24点阵黑体 字模，72 byte */
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x1F,0xFF,0xF8,0x1F,0xFF,0xF8,0x18,
 0xC2,0x18,0x18,0xC2,0x18,0x18,0xC2,0x18,
 0x1F,0xFF,0xF8,0x1F,0xFF,0xF8,0x00,0x40,
 0x00,0x00,0xE0,0x00,0x00,0xFF,0xE0,0x01,
 0xFF,0xE0,0x03,0x00,0xC0,0x0E,0x00,0xC0,
 0x0C,0x31,0x80,0x00,0x39,0x80,0x00,0x1F,
 0x00,0x00,0x0E,0x00,0x00,0x7C,0x00,0x1F,
 0xF0,0x00,0x1F,0x80,0x00,0x00,0x00,0x00};

char si[72] =     /* 以下是 '斯' 的 24点阵黑体 字模，72 byte */
{0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x60,
 0x0C,0x0C,0x63,0xFC,0x0C,0x62,0x00,0x3F,
 0xFA,0x00,0x0C,0x62,0x00,0x0C,0x62,0x00,
 0x0F,0xE2,0x00,0x0F,0xE3,0xFE,0x0C,0x63,
 0xFE,0x0C,0x62,0x30,0x0F,0xE2,0x30,0x0C,
 0x62,0x30,0x0C,0x62,0x30,0x7F,0xFE,0x30,
 0x7F,0xFE,0x30,0x08,0x86,0x30,0x0C,0xC6,
 0x30,0x1C,0x6C,0x30,0x38,0x3C,0x30,0x30,
 0x18,0x30,0x00,0x18,0x30,0x00,0x00,0x00};

char fan[72] =    /* 以下是 '方' 的 24点阵黑体 字模，72 byte */
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,
 0x00,0x00,0x18,0x00,0x00,0x18,0x00,0x00,
 0x10,0x00,0x7F,0xFF,0xFE,0x78,0x60,0x1E,
 0x00,0x60,0x00,0x00,0x60,0x00,0x00,0x60,
 0x00,0x00,0xFF,0xE0,0x00,0xFF,0xE0,0x00,
 0xC0,0x60,0x00,0xC0,0x60,0x00,0xC0,0x60,
 0x01,0x80,0x60,0x01,0x80,0x60,0x03,0x00,
 0x60,0x07,0x00,0xC0,0x0E,0x00,0xC0,0x3C,
 0x07,0xC0,0x18,0x07,0x80,0x00,0x00,0x00};

char kuai[72] =   /* 以下是 '块' 的 24点阵黑体 字模，72 byte */
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,
 0x00,0x0C,0x06,0x00,0x0C,0x06,0x00,0x04,
 0x06,0x00,0x04,0x7F,0xF0,0x04,0x06,0x30,
 0x7F,0x86,0x30,0x7F,0x86,0x30,0x04,0x06,
 0x30,0x04,0x06,0x30,0x04,0x06,0x30,0x04,
 0x7F,0xFC,0x04,0x06,0x00,0x04,0x07,0x00,
 0x05,0x8D,0x80,0x1F,0x8D,0x80,0x3C,0x18,
 0xC0,0x20,0x30,0x70,0x00,0xE0,0x3C,0x01,
 0xC0,0x1E,0x01,0x80,0x04,0x00,0x00,0x00};

char xia[32] =    /* 以下是 '下' 的 16点阵宋体 字模，32 byte */
{0x00,0x04,0x7F,0xFE,0x01,0x00,0x01,0x00,
 0x01,0x00,0x01,0xC0,0x01,0x60,0x01,0x30,
 0x01,0x20,0x01,0x00,0x01,0x00,0x01,0x00,
 0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x00};


char yi[32] =     /* 以下是 '一' 的 16点阵宋体 字模，32 byte */
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x04,0x7F,0xFE,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};


char ge[32] =     /* 以下是 '个' 的 16点阵宋体 字模，32 byte */
{0x01,0x00,0x01,0x00,0x02,0x80,0x02,0x40,
 0x04,0x20,0x09,0x18,0x11,0x0E,0x61,0x04,
 0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,
 0x01,0x00,0x01,0x00,0x01,0x00,0x00,0x00};


char fen[32] =    /* 以下是 '分' 的 16点阵宋体 字模，32 byte */
{0x08,0x80,0x0C,0x80,0x08,0x40,0x10,0x20,
 0x10,0x30,0x20,0x18,0x40,0x0E,0x9F,0xE4,
 0x04,0x20,0x04,0x20,0x04,0x20,0x04,0x20,
 0x08,0x20,0x10,0xA0,0x20,0x40,0x40,0x00};


char shu[32] =    /* 以下是 '数' 的 16点阵宋体 字模，32 byte */
{0x08,0x20,0x49,0x30,0x2A,0x20,0x1C,0x20,
 0xFF,0x7E,0x1C,0x44,0x2B,0x44,0x48,0xC4,
 0x08,0x28,0xFF,0x28,0x12,0x10,0x34,0x10,
 0x0C,0x28,0x32,0x4E,0xC0,0x84,0x00,0x00};

char maohao[32] = /* 以下是 '：' 的 16点阵楷体_GB2312 字模，32 byte */
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,
 0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x20,0x00,0x30,0x00,0x00,0x00,0x00,0x00};


char liao[32] =   /* 以下是 '廖' 的 16点阵楷体_GB2312 字模，32 byte */
{0x01,0x00,0x00,0x80,0x03,0xF0,0x0C,0x38,
 0x0F,0xD0,0x0D,0x50,0x13,0x70,0x14,0x90,
 0x11,0x60,0x12,0x18,0x25,0xCE,0x5A,0x40,
 0x40,0xA0,0x83,0x40,0x00,0x80,0x03,0x00};

char jin[32] =    /* 以下是 '金' 的 16点阵楷体_GB2312 字模，32 byte */
{0x00,0x00,0x01,0x00,0x03,0x00,0x02,0x80,
 0x04,0x40,0x0C,0x20,0x08,0x58,0x17,0x8F,
 0x61,0x00,0x83,0xC0,0x05,0x00,0x09,0x40,
 0x05,0x80,0x01,0x78,0x3E,0x80,0x00,0x00};

char hai[32] =    /* 以下是 '海' 的 16点阵楷体_GB2312 字模，32 byte */
{0x00,0x00,0x00,0x80,0x00,0x80,0x19,0x70,
 0x0A,0x80,0x04,0x30,0x21,0xD0,0x01,0x50,
 0x02,0x7E,0x1F,0x90,0x12,0x10,0x26,0x10,
 0x65,0xFC,0x00,0x20,0x00,0x60,0x00,0x00};

char you[72] =    /* 以下是 '游' 的 24点阵楷体_GB2312 字模，72 byte */
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x80,0x00,0x20,0x80,0x0C,0x31,0x80,0x06,
 0x11,0x38,0x02,0x01,0xE0,0x00,0x1A,0x00,
 0x00,0xF4,0x20,0x33,0xC0,0xF0,0x10,0x43,
 0x60,0x00,0x70,0x40,0x00,0x91,0x80,0x04,
 0x90,0x8C,0x05,0x11,0xFE,0x09,0x3E,0xC0,
 0x1A,0x20,0x40,0x1C,0x20,0x40,0x30,0xC0,
 0xC0,0x10,0x40,0xC0,0x00,0x03,0xC0,0x00,
 0x01,0x80,0x00,0x01,0x80,0x00,0x00,0x00};

char xi[72] =     /* 以下是 '戏' 的 24点阵楷体_GB2312 字模，72 byte */
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,
 0x00,0x00,0x0C,0x00,0x00,0x0C,0x40,0x00,
 0x0C,0x30,0x00,0x04,0x10,0x00,0x84,0x00,
 0x0F,0xC4,0xE0,0x30,0x87,0x80,0x21,0x9E,
 0x00,0x19,0x86,0x20,0x07,0x02,0x60,0x03,
 0x03,0xC0,0x03,0x83,0x80,0x06,0xC1,0x80,
 0x04,0x67,0x80,0x08,0x0C,0xC0,0x10,0x30,
 0x44,0x60,0x40,0x64,0x00,0x00,0x34,0x00,
 0x00,0x1C,0x00,0x00,0x0E,0x00,0x00,0x00};

char jie[72] =    /* 以下是 '结' 的 24点阵楷体_GB2312 字模，72 byte */
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x03,0x00,0x02,0x03,0x00,0x02,
 0x03,0x00,0x06,0x03,0x00,0x04,0xC3,0x00,
 0x08,0xC3,0x30,0x18,0x83,0xF8,0x3F,0x7D,
 0x00,0x32,0x01,0x00,0x06,0x01,0x00,0x0D,
 0x83,0xE0,0x1E,0x1C,0x00,0x18,0x00,0x00,
 0x00,0x01,0xF0,0x03,0x9E,0x30,0x0E,0x10,
 0x20,0x38,0x10,0x20,0x10,0x13,0xE0,0x00,
 0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00};

char shu2[72] =    /* 以下是 '束' 的 24点阵楷体_GB2312 字模，72 byte */
{0x00,0x00,0x00,0x00,0x30,0x00,0x00,0x10,
 0x00,0x00,0x10,0x00,0x00,0x1F,0x00,0x00,
 0xFC,0x00,0x00,0x10,0x00,0x00,0x10,0x00,
 0x00,0x1F,0xC0,0x07,0xF0,0xC0,0x02,0x11,
 0x80,0x02,0x13,0x00,0x01,0xFC,0x00,0x00,
 0x30,0x00,0x00,0x58,0x00,0x00,0xD6,0x00,
 0x01,0x13,0x80,0x02,0x10,0xE0,0x0C,0x10,
 0x7C,0x10,0x10,0x3E,0x60,0x30,0x00,0x00,
 0x10,0x00,0x00,0x10,0x00,0x00,0x00,0x00};

char chen[32] =   /* 以下是 '程' 的 16点阵宋体 字模，32 byte */
{0x0D,0xF8,0x71,0x08,0x11,0x08,0x11,0x08,
 0xFD,0x08,0x11,0xF8,0x30,0x00,0x3B,0xFC,
 0x54,0x40,0x50,0x40,0x93,0xFC,0x10,0x40,
 0x10,0x40,0x10,0x40,0x17,0xFE,0x10,0x00};

char xu[32]  =   /* 以下是 '序' 的 16点阵宋体 字模，32 byte */
{0x01,0x00,0x00,0x80,0x3F,0xFE,0x20,0x00,
 0x27,0xF8,0x21,0x10,0x20,0xA0,0x20,0x40,
 0x2F,0xFE,0x20,0x44,0x20,0x40,0x20,0x40,
 0x20,0x40,0x40,0x40,0x41,0x40,0x80,0x80};

char she[32]  =   /* 以下是 '设' 的 16点阵宋体 字模，32 byte */
{0x40,0x00,0x21,0xF0,0x31,0x10,0x21,0x10,
 0x01,0x10,0x01,0x10,0xE2,0x0E,0x25,0xF8,
 0x21,0x08,0x21,0x08,0x20,0x90,0x20,0x90,
 0x28,0x60,0x30,0x90,0x23,0x0E,0x0C,0x04};

char ji[32]   =   /* 以下是 '计' 的 16点阵宋体 字模，32 byte */
{0x40,0x20,0x20,0x20,0x30,0x20,0x20,0x20,
 0x00,0x20,0xF3,0xFE,0x10,0x20,0x10,0x20,
 0x10,0x20,0x10,0x20,0x10,0x20,0x12,0x20,
 0x14,0x20,0x18,0x20,0x10,0x20,0x00,0x20};

/************************** FanKuai Data Structure **************************/
struct
   {
     int value;           /*1为已填充，0为未填充*/
     int color;           /*方格在已填充时显示的方块的颜色*/
   }board[20][12];       

int fank[7][4][9] =  /*第一维为状态值，第二维为方向值，第三维第八个数为颜色值*/
   {
     { {1,1,1,2,2,1,2,2,1},      //  x x x x
       {1,1,1,2,2,1,2,2,2},      //  x # # x
       {1,1,1,2,2,1,2,2,3},      //  x # # x
       {1,1,1,2,2,1,2,2,4}       //  x x x x
     },
     { {0,1,1,1,2,1,3,1,5},      //  x # x x   x x x x
       {1,0,1,1,1,2,1,3,6},      //  x # x x   # # # #
       {0,1,1,1,2,1,3,1,9},      //  x # x x   x x x x
       {1,0,1,1,1,2,1,3,10}      //  x # x x   x x x x
     },
     { {1,2,2,1,2,2,3,1,11},     //  x x x x   x x x x
       {1,0,1,1,2,1,2,2,12},     //  x x # x   # # x x
       {1,2,2,1,2,2,3,1,13},     //  x # # x   x # # x
       {1,0,1,1,2,1,2,2,14}      //  x # x x   x x x x
     },
     { {1,1,2,1,2,2,3,2,13},     //  x x x x   x x x x
       {1,1,1,2,2,0,2,1,11},     //  x # x x   x # # x
       {1,1,2,1,2,2,3,2,9},      //  x # # x   # # x x
       {1,1,1,2,2,0,2,1,6}       //  x x # x   x x x x
     },
     { {1,0,1,1,1,2,2,1,4},      //  x x x x   x x x x   x x x x   x x x x
       {1,2,2,1,2,2,3,2,2},      //  # # # x   x x # x   x # x x   x # x x
       {1,1,2,0,2,1,2,2,3},      //  x # x x   x # # x   # # # x   x # # x
       {1,1,2,1,2,2,3,1,1}       //  x x x x   x x # x   x x x x   x # x x
     },
     { {1,1,1,2,2,2,3,2,14},     //  x x x x   x x x x   x x x x   x x x x
       {1,2,2,0,2,1,2,2,12},     //  x # # x   x x # x   x # x x   # # # x
       {1,1,2,1,3,1,3,2,10},     //  x x # x   # # # x   x # x x   # x x x
       {1,0,1,1,1,2,2,0,5}       //  x x # x   x x x x   x # # x   x x x x
     },
     { {1,1,1,2,2,1,3,1,2},      //  x x x x   x x x x   x x x x   x x x x
       {1,0,1,1,1,2,2,2,1},      //  x # # x   # # # x   x x # x   # x x x
       {1,2,2,2,3,1,3,2,4},      //  x # x x   x x # x   x x # x   # # # x
       {1,0,2,0,2,1,2,2,11}      //  x # x x   x x x x   x # # x   x x x x
     }
   };

/***************************** variable ************************************/
int x, y;                              /* 当前方块在面板中的坐标   */
int i, j;                              /* 当前方块的状态值和方向值 */
int start, count = 0, tfinish;         /* tfinish:方块下落的时间   */
long result;                           /* 分数                     */

/*********************** function prototype ********************************/
void GraphInit(void);
void GraphEnd(void);
void ViewInit(void);
void DataInit(void);
void DrawBoard(int flag, int color, int x, int y, int lengthx, int lengthy);
void DrawFanK(int x, int y, int m, int n, int a, int b);
void DisNext(int m, int n);
int  Check(int key);
void MoveFanK(int key);
void DelFanK(void);
void DelRow(int x);
int  GameOver(void);
void DataFill(void);
void DisResult(void);
void Level(void);
void DrawMat(char *mat,int matsize,int x,int y,int color);
void interrupt (*OldTimer)();
void interrupt NewTimer();
void Install(void interrupt (*fadd)());

/*************************** main function *********************************/
void main()
{
  int key;
  int tempi, tempj;
  int ok;                               /* 控制是否开始生成新方块 */
  GraphInit();
  randomize();
  OldTimer = getvect(0x1c);
  Install(NewTimer);
  while (1)
    {
      DataInit();
      ViewInit();
      ok = 1;
      x = 0; y = 4;
      tempi = random(7);
      tempj = random(4);
      while (1)
	{
	  if (ok == 1)
	     {
	       ok = 0;
	       i = tempi; tempi = random(7);
	       j = tempj; tempj = random(4);
	       if ((i == 1) && ((j == 0) || (j == 2))) x = 1;
	       if (Check(0) == 1)
		    DrawFanK(x, y, i, j, 95, 50);
	       else
		  {
		    start = 0;
		    key = GameOver();
		    break;
		  }
	       DisNext(tempi, tempj);
	     }
	  if (bioskey(1) != 0) key = bioskey(0);
	  else key = 0;
	  if ((key == ESC) || (key == ENTER)) break;
	  if (key ==SPACE)
	     {
	       if (start == 1) start = 0;//start = (start == 1? 0:1); or start ^= 1;
	       else start = 1;
	     }
	  if (((key == DOWN) || (count > tfinish)) && (Check(DOWN) == 0))
	     {
	       DataFill();
	       DelFanK();
	       DisResult();
	       Level();
	       ok = 1;
	       count = 0;
	       x = 0; y = 4;
	       continue;
	     }
	 if ((key != 0) && (Check(key) == 1)) MoveFanK(key);
	 if ((count > tfinish) && (Check(DOWN) == 1))
	    {
	      count = 0;
	      MoveFanK(DOWN);
	    }
	}
      if (key == ESC) break;
    }
  Install(OldTimer);
  GraphEnd();
}

/***************************** user's function *****************************/
void GraphInit(void)
{
  int gdriver = DETECT;
  int gmode;
  registerbgidriver(EGAVGA_driver);
  initgraph(&gdriver, &gmode, "c:\\tc\\bgi");
}

void GraphEnd(void)
{
  closegraph();
}

void ViewInit(void)
{
  rectangle(0, 0, 639, 479);
  setfillstyle(SOLID_FILL, BLUE);
  bar(1, 1, 638, 478);

  DrawBoard(1, 7, 100, 30, 440, 420);
  DrawBoard(1, 7, 105, 60, 430, 385);
  DrawBoard(-1, 7, 115, 70, 204, 364);
  DrawBoard(-1, 7, 350, 110, 90, 90);
  DrawBoard(-1, 7, 350, 230, 120, 30);
  DrawBoard(-1, 7, 350, 300, 165, 110);

  DrawMat(qi, 24, 235, 34, RED);
  DrawMat(cai, 24, 260, 34, RED);
  DrawMat(e, 24, 285, 34, RED);
  DrawMat(luo, 24, 310, 34, RED);
  DrawMat(si, 24, 335, 34, RED);
  DrawMat(fan, 24, 360, 34, RED);
  DrawMat(kuai, 24, 385, 34, RED);

  DrawMat(xia, 16, 350, 90, 0);
  DrawMat(yi, 16, 367, 90, 0);
  DrawMat(ge, 16, 386, 90, 0);
  DrawMat(maohao, 16, 403, 90, 0);

  DrawMat(fen, 16, 353, 238, 0);
  DrawMat(shu, 16, 370, 238, 0);
  DrawMat(maohao, 16, 388, 238, 0);

  DrawMat(chen, 16, 360, 355, BLUE);
  DrawMat(xu, 16, 378, 355, BLUE);
  DrawMat(she, 16, 396, 355, BLUE);
  DrawMat(ji, 16, 414, 355, BLUE);
  DrawMat(maohao, 16, 432, 355, BLUE);

  DrawMat(liao, 16, 440, 355, RED);
  DrawMat(jin, 16, 458, 355, RED);
  DrawMat(hai, 16, 476, 355, RED);

  setcolor(BLUE);
  outtextxy(360, 315, "Version: 1.0");
  outtextxy(360, 335, "Haisoft Corporation");
  outtextxy(360, 385, "jinhailiao@163.com");


  DisResult();
}

void DataInit(void)
{
  register int i, j;

  start = 1;
  count = 0; tfinish = 20;
  result = 0;

  for (i = 0; i < 20; i++)
    for (j = 0; j < 12; j++)
       {
	 if ((i == 0) || (i == 19) || (j == 0) || (j == 11))
	      board[i][j].value = 1;
	 else
	      board[i][j].value = 0;
	 board[i][j].color = -1;
       }
}
     /* flag:为1凸出,为-1凹进;   x,y:坐标;   lengthx,lengthy:长宽; */
void DrawBoard(int flag, int color, int x, int y, int lengthx, int lengthy)
{
  int color1 = 15, color2 = 8;
  int lengx = lengthx - 1, lengy = lengthy - 1;
  if (flag <= 0)
     {
       color1 = 8;
       color2 = 15;
     }
  setcolor(color1);
  line(x, y, x+lengx, y);
  line(x+1, y+1, x+lengx-1, y+1);
  line(x, y, x, y+lengy);
  line(x+1, y+1, x+1, y+lengy-1);
  setcolor(color2);
  line(x, y+lengy, x+lengx, y+lengy);
  line(x+1, y+lengy-1, x+lengx-1, y+lengy-1);
  line(x+lengx, y, x+lengx, y+lengy);
  line(x+lengx-1, y+1, x+lengx-1, y+lengy-1);
  setfillstyle(SOLID_FILL, color);
  bar(x+2, y+2, x+lengx-2, y+lengy-2);
}
       /* x,y:方块在面板上的坐标; m,n:方块的状态和方向;a,b:面板的左上角坐标 */
void DrawFanK(int x, int y, int m, int n, int a, int b)
{
  register int i;
  int tempx, tempy;
  for (i = 0; i < 8; i += 2)
     {
       tempx = x + fank[m][n][i];
       tempy = y + fank[m][n][i+1];
       DrawBoard(1, fank[m][n][8], a+tempy*20+2, b+tempx*20+2, 20, 20);
     }
}

void DisNext(int m, int n)
{
   int a, b;
   switch (m)
      {
	case 0: a = 353; b = 113; break;
	case 1: switch (n)
		   {
		     case 0:
		     case 2:  a = 363; b = 113; break;
		     default: a = 353; b = 123; break;
		   }
		break;
	case 2: switch (n)
		   {
		     case 0:
		     case 2:  a = 353; b = 103; break;
		     default: a = 363; b = 113; break;
		   }
		break;
	case 3: switch (n)
		   {
		     case 0:
		     case 2:  a = 353; b = 103; break;
		     default: a = 363; b = 113; break;
		   }
		break;
	case 4: switch (n)
		   {
		     case 0:
		     case 2:  a = 363; b = 113; break;
		     default: a = 353; b = 103; break;
		   }
		break;
	case 5: switch (n)
		   {
		     case 0:
		     case 2:  a = 353; b = 103; break;
		     default: a = 363; b = 113; break;
		   }
		break;
	default:switch (n)
		   {
		     case 0:
		     case 2:  a = 353; b = 103; break;
		     default: a = 363; b = 113; break;
		   }
		break;
      }
   setfillstyle(SOLID_FILL, 7);
   bar(355, 115, 434, 196);
   DrawFanK(0, 0, m, n, a, b);
}

int Check(int key)
{
  register int k;
  int tempx, tempy, tx, ty, ti, tj;
  tx = x; ty = y;
  ti = i; tj = j;
  switch (key)
    {
      case UP:   tj = (tj+1)%4; break;
      case DOWN: tx = tx + 1;   break;
      case LEFT: ty = ty - 1;   break;
      case RIGHT:ty = ty + 1;   break;
      default:   break;
    }
  for (k = 0; k < 8; k += 2)
     {
       tempx = tx + fank[ti][tj][k];
       tempy = ty + fank[ti][tj][k+1];
       if (board[tempx][tempy].value == 1) return 0;
     }
  return 1;
}

void MoveFanK(int key)
{
  register int k;
  int tempx, tempy;
  if ((key != UP) && (key != DOWN) && (key != LEFT) && (key != RIGHT)) return;
  setfillstyle(SOLID_FILL, 7);
  for (k = 0; k < 8; k += 2)
     {
       tempx = x + fank[i][j][k];
       tempy = y + fank[i][j][k+1];
       bar(95+tempy*20+2, 50+tempx*20+2, 95+tempy*20+1+20, 50+tempx*20+1+20);
     }
  switch (key)
     {
       case UP:   j = (j+1)%4; break;
       case DOWN: x = x + 1;   break;
       case LEFT: y = y - 1;   break;
       case RIGHT:y = y + 1;   break;
       default:   return;
     }
  DrawFanK(x, y, i, j, 95, 50);
}

void DelFanK(void)
{
  int num = 0, flag;
  int vol;
  register int tx, ty;
  if (x == 0) return;
  for (tx = x; (tx<19)&&(tx<x+4); tx++)
     {
       flag = 1;
       for (ty = 1; ty < 11; ty++)
	    if (board[tx][ty].value == 0)
	       {
		 flag = 0;
		 break;
	       }
       if (flag == 1)
	  {
	    DelRow(tx);
	    num++;
	  }
     }
  switch (num)
    {
      case 1:  vol = 100;  break;
      case 2:  vol = 400;  break;
      case 3:  vol = 1000; break;
      case 4:  vol = 2000; break;
      default: vol = 0;    break;
    }
  result += vol;
}

void DelRow(int x)         /*删去X行*/
{
  int flag;
  register int tx, ty;
  setfillstyle(SOLID_FILL, 7);       /*快速显示删去的行*/
  for (ty = 1; ty < 11; ty++)
     DrawBoard(1, 7, 95+ty*20+2, 50+x*20+2, 20, 20);
  delay(50);
  for (tx = x; tx > 1; tx--)
     {
       flag = 1;
       for (ty = 1; ty < 11; ty++)
	     {
	       if (board[tx-1][ty].value == 1) flag = 0;
	       board[tx][ty].value = board[tx-1][ty].value;
	       board[tx][ty].color = board[tx-1][ty].color;
	       if (board[tx][ty].value == 1)
		  DrawBoard(1, board[tx][ty].color, 95+ty*20+2, 50+tx*20+2, 20, 20);
	       else
		  {
		    setfillstyle(SOLID_FILL, 7);
		    bar(95+ty*20+2, 50+tx*20+2, 95+ty*20+1+20, 50+tx*20+1+20);
		  }
	     }
       if (flag == 1) return;
       if (tx-1 == 1)
	  for (ty = 1; ty < 11; ty++)
	    if (board[1][ty].value == 1)
	      {
		board[1][ty].value = 0;
		board[1][ty].color = -1;
		setfillstyle(SOLID_FILL, 7);
		bar(95+ty*20+2, 50+1*20+2, 95+ty*20+1+20, 50+1*20+1+20);
	      }
     }
}

void DataFill(void)
{
  register int k;
  int tempx, tempy;
  for (k = 0; k < 8; k += 2)
    {
      tempx = x + fank[i][j][k];
      tempy = y + fank[i][j][k+1];
      board[tempx][tempy].value = 1;
      board[tempx][tempy].color = fank[i][j][8];
    }
}

void DisResult(void)
{
  char num[10];
  ltoa(result, num, 10);
  setfillstyle(SOLID_FILL, 7);
  bar(395, 235, 465, 255);
  setcolor(RED);
  outtextxy(400, 244, num);

}

void Level(void)
{
  if (result > 200000)  {tfinish = 3; return;}
  if (result > 150000)  {tfinish = 5; return;}
  if (result > 100000)  {tfinish = 7; return;}
  if (result > 50000)   {tfinish = 10; return;}
  if (result > 10000)   {tfinish = 13; return;}
  if (result > 6000)    {tfinish = 16; return;}
  if (result > 3000)    {tfinish = 18; return;}
}

void DrawMat(char *mat,int matsize,int x,int y,int color)
/*依次：字模指针、点阵大小、起始坐标(x,y)、颜色*/
{int i,j,k,n;
 n = (matsize-1)/8+1;
 for (j=0;j<matsize;j++)
   for (i=0;i<n;i++)
     for (k=0;k<8;k++)
       if (mat[j*n+i]&(0x80>>k))  /*测试为1的位则显示*/
	 putpixel(x+i*8+k,y+j,color);
}


int GameOver(void)
{
  int key;
  DrawBoard(1, 7, 140, 200, 150, 60);
  DrawBoard(-1, 7, 150, 210, 130, 40);
  DrawMat(you, 24, 165, 218, BLACK);
  DrawMat(xi, 24, 190, 218, BLACK);
  DrawMat(jie, 24, 215, 218, BLACK);
  DrawMat(shu2, 24, 240, 218, BLACK);
  while (1)
    {
      if (bioskey(1) != 0) key = bioskey(0);
      else key = 0;
      if (key == ESC) return ESC;
      if (key == ENTER) return ENTER;
    }
}

void Install(void interrupt (*fadd)())
{
  disable();
  setvect(0x1c, fadd);
  enable();
}

void interrupt NewTimer()
{
  OldTimer();
  if (start == 1) count++;
}